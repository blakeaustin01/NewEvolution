<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Remembering World</title>

<style>
  body {
    margin: 0;
    background: #0f0f0f;
    color: #ddd;
    font-family: system-ui, sans-serif;
    overflow: hidden;
  }

  #overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    min-height: 90px;
    padding: 10px;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(6px);
    font-size: 14px;
    line-height: 1.4;
  }

  canvas {
    display: block;
  }

  .hint {
    opacity: 0.6;
    font-size: 12px;
  }
</style>
</head>

<body>
<canvas id="c"></canvas>
<div id="overlay">
  <div id="text">Move. Pause. Return. The world is watching patterns, not goals.</div>
  <div class="hint">Touch + drag or arrow keys</div>
</div>

<script>
/* =========================
   CONFIG
========================= */

const ENABLE_GPT = false; // set true later if you want
const OPENAI_API_KEY = "PASTE_KEY_HERE_IF_USED";

/* =========================
   CANVAS SETUP
========================= */

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - 100;
}
window.addEventListener("resize", resize);
resize();

/* =========================
   WORLD STATE
========================= */

const player = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  r: 8
};

let zones = [];
let history = [];
let lastReflectionTime = 0;
let lastPattern = null;

function createZones() {
  zones = [];
  for (let i = 0; i < 12; i++) {
    zones.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      r: 30 + Math.random() * 40,
      hue: Math.random() * 360,
      stability: 1
    });
  }
}
createZones();

/* =========================
   INPUT (TOUCH + KEYS)
========================= */

let target = null;

canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  target = { x: t.clientX, y: t.clientY - 100 };
});

canvas.addEventListener("touchmove", e => {
  const t = e.touches[0];
  target = { x: t.clientX, y: t.clientY - 100 };
});

canvas.addEventListener("touchend", () => target = null);

const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

/* =========================
   UPDATE LOOP
========================= */

function update() {
  const speed = 1.8;
  let moved = false;

  if (target) {
    const dx = target.x - player.x;
    const dy = target.y - player.y;
    player.x += dx * 0.05;
    player.y += dy * 0.05;
    moved = true;
  }

  if (keys.ArrowUp) { player.y -= speed; moved = true; }
  if (keys.ArrowDown) { player.y += speed; moved = true; }
  if (keys.ArrowLeft) { player.x -= speed; moved = true; }
  if (keys.ArrowRight) { player.x += speed; moved = true; }

  if (moved) {
    history.push({ x: player.x, y: player.y, t: Date.now() });
    if (history.length > 300) history.shift();
  }

  evolveWorld();
  maybeReflect();
}

/* =========================
   WORLD EVOLUTION
========================= */

function evolveWorld() {
  zones.forEach(z => {
    const dx = player.x - z.x;
    const dy = player.y - z.y;
    const d = Math.hypot(dx, dy);

    if (d < z.r + 20) {
      z.stability += 0.01;
      z.hue += 0.3;
    } else {
      z.stability -= 0.002;
    }

    z.stability = Math.max(0.3, Math.min(2, z.stability));
  });
}

/* =========================
   PATTERN RECOGNITION
========================= */

function detectPattern() {
  if (history.length < 120) return null;

  let pauses = 0;
  let returns = 0;

  for (let i = 2; i < history.length; i++) {
    const a = history[i];
    const b = history[i - 2];
    if (Math.hypot(a.x - b.x, a.y - b.y) < 5) pauses++;
  }

  zones.forEach(z => {
    let count = history.filter(p => Math.hypot(p.x - z.x, p.y - z.y) < z.r).length;
    if (count > 40) returns++;
  });

  if (pauses > 30) return "hesitation";
  if (returns > 2) return "attachment";
  if (history.length > 250) return "wandering";

  return null;
}

/* =========================
   REFLECTION (TEXT)
========================= */

function maybeReflect() {
  const now = Date.now();
  if (now - lastReflectionTime < 12000) return;

  const pattern = detectPattern();
  if (!pattern || pattern === lastPattern) return;

  lastPattern = pattern;
  lastReflectionTime = now;

  const text = {
    hesitation: "The world notices when motion circles without committing.",
    attachment: "Some places hold you longer than they should. They begin to change.",
    wandering: "Distance accumulates. Direction does not."
  }[pattern];

  showText(text);
}

function showText(t) {
  document.getElementById("text").innerText = t;
}

/* =========================
   DRAW
========================= */

function draw() {
  ctx.fillStyle = "#0f0f0f";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  zones.forEach(z => {
    ctx.fillStyle = `hsla(${z.hue}, 50%, 40%, ${z.stability / 2})`;
    ctx.beginPath();
    ctx.arc(z.x, z.y, z.r * z.stability, 0, Math.PI * 2);
    ctx.fill();
  });

  ctx.fillStyle = "white";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
  ctx.fill();
}

/* =========================
   LOOP
========================= */

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
